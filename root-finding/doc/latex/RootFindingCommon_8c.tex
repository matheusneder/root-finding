\hypertarget{RootFindingCommon_8c}{
\subsection{src/RootFindingCommon.c File Reference}
\label{RootFindingCommon_8c}\index{src/RootFindingCommon.c@{src/RootFindingCommon.c}}
}
/root-finding/src/RootFindingCommon.c 

{\tt \#include \char`\"{}RootFindingCommon.h\char`\"{}}\par
{\tt \#include $<$string.h$>$}\par
{\tt \#include $<$math.h$>$}\par
\subsubsection*{Functions}
\begin{CompactItemize}
\item 
\hyperlink{RootFindingCommon_8h_31228d356f5429fa5ba7f206e4dee12f}{RootFindingBoolT} \hyperlink{RootFindingCommon_8c_76a682bfff8a85e4c26013247db1b0ab}{getAxisVarPtr} (muParserHandle\_\-t mupObj, const char $\ast$axis, \hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} $\ast$$\ast$varPtr)
\begin{CompactList}\small\item\em Obtem o endereco para a variavel do eixo onde deve-se. \item\end{CompactList}\item 
\hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} \hyperlink{RootFindingCommon_8c_d90aee6760bcf8fbfd5dbc3b52934e70}{infinity} ()
\begin{CompactList}\small\item\em Obtem o valor infinito. \item\end{CompactList}\item 
\hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} \hyperlink{RootFindingCommon_8c_977a6bd4f033997ff5d5408c9ecf3ec9}{Mup2ndDiff} (muParserHandle\_\-t mupObj, \hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} $\ast$varPtr)
\begin{CompactList}\small\item\em Aproximacao da segunda diferencial no ponto utilizando \char`\"{}Finite difference\char`\"{}. \item\end{CompactList}\item 
\hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} \hyperlink{RootFindingCommon_8c_3d3296b37f9383ae7b5257b5523e0d43}{MupDiff} (muParserHandle\_\-t mupObj, \hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} $\ast$varPtr)
\begin{CompactList}\small\item\em Aproximacao da diferencial no ponto utilizando \char`\"{}regard to a variable\char`\"{} O codigo foi adaptado para C c/ base no metodo Diff da classe muParser (C++), infelizmente a API para C do muParser nao disbonibiliza o metodo Diff. \item\end{CompactList}\item 
\hyperlink{RootFindingCommon_8h_31228d356f5429fa5ba7f206e4dee12f}{RootFindingBoolT} \hyperlink{RootFindingCommon_8c_92bc6cb79bbeafa779507dd6384b6ff6}{isInfOrNan} (\hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} num)
\begin{CompactList}\small\item\em Verifica se um dado numero \hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} eh infinito ou \char`\"{}Not a Number\char`\"{}. \item\end{CompactList}\end{CompactItemize}


\subsubsection{Detailed Description}
/root-finding/src/RootFindingCommon.c 

\begin{Desc}
\item[Date:]25/03/2010 \end{Desc}
\begin{Desc}
\item[Author:]Matheus Neder $<$\href{mailto:matheusneder@gmail.com}{\tt matheusneder@gmail.com}$>$ \end{Desc}


Definition in file \hyperlink{RootFindingCommon_8c-source}{RootFindingCommon.c}.

\subsubsection{Function Documentation}
\hypertarget{RootFindingCommon_8c_76a682bfff8a85e4c26013247db1b0ab}{
\index{RootFindingCommon.c@{RootFindingCommon.c}!getAxisVarPtr@{getAxisVarPtr}}
\index{getAxisVarPtr@{getAxisVarPtr}!RootFindingCommon.c@{RootFindingCommon.c}}
\paragraph[getAxisVarPtr]{\setlength{\rightskip}{0pt plus 5cm}{\bf RootFindingBoolT} getAxisVarPtr (muParserHandle\_\-t {\em mupObj}, \/  const char $\ast$ {\em axis}, \/  {\bf RootFindingDoubleT} $\ast$$\ast$ {\em varPtr})}\hfill}
\label{RootFindingCommon_8c_76a682bfff8a85e4c26013247db1b0ab}


Obtem o endereco para a variavel do eixo onde deve-se. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em mupObj}]Ponteiro para objeto muParser contendo a expressao \item[{\em axis}]Eixo em qual a raiz deve ser procurada \item[\mbox{$\rightarrow$} {\em varPtr}]Ponteiro para onde o endereco deve ser atribuido \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]TRUE em caso de sucesso FALSE em caso de falha \end{Desc}


Definition at line 30 of file RootFindingCommon.c.

References FALSE, RootFindingPegaso::i, and TRUE.\hypertarget{RootFindingCommon_8c_d90aee6760bcf8fbfd5dbc3b52934e70}{
\index{RootFindingCommon.c@{RootFindingCommon.c}!infinity@{infinity}}
\index{infinity@{infinity}!RootFindingCommon.c@{RootFindingCommon.c}}
\paragraph[infinity]{\setlength{\rightskip}{0pt plus 5cm}{\bf RootFindingDoubleT} infinity ()}\hfill}
\label{RootFindingCommon_8c_d90aee6760bcf8fbfd5dbc3b52934e70}


Obtem o valor infinito. 

\begin{Desc}
\item[Returns:]inf \end{Desc}


Definition at line 55 of file RootFindingCommon.c.

Referenced by RootFindingBaseReset(), RootFindingBissecaoInit(), RootFindingCordasInit(), and RootFindingNewtonRhapsonInit().\hypertarget{RootFindingCommon_8c_92bc6cb79bbeafa779507dd6384b6ff6}{
\index{RootFindingCommon.c@{RootFindingCommon.c}!isInfOrNan@{isInfOrNan}}
\index{isInfOrNan@{isInfOrNan}!RootFindingCommon.c@{RootFindingCommon.c}}
\paragraph[isInfOrNan]{\setlength{\rightskip}{0pt plus 5cm}{\bf RootFindingBoolT} isInfOrNan ({\bf RootFindingDoubleT} {\em num})}\hfill}
\label{RootFindingCommon_8c_92bc6cb79bbeafa779507dd6384b6ff6}


Verifica se um dado numero \hyperlink{RootFindingCommon_8h_a296fe63994e03408c4ad62794d472e9}{RootFindingDoubleT} eh infinito ou \char`\"{}Not a Number\char`\"{}. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em num}]Numero a verificado \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]TRUE se isinf(num) ou isnan(num) \end{Desc}


Definition at line 97 of file RootFindingCommon.c.

Referenced by RootFindingBissecaoPerformIteration(), RootFindingCordasPerformIteration(), RootFindingNewtonRhapsonPerformIteration(), and RootFindingPegasoPerformIteration().\hypertarget{RootFindingCommon_8c_977a6bd4f033997ff5d5408c9ecf3ec9}{
\index{RootFindingCommon.c@{RootFindingCommon.c}!Mup2ndDiff@{Mup2ndDiff}}
\index{Mup2ndDiff@{Mup2ndDiff}!RootFindingCommon.c@{RootFindingCommon.c}}
\paragraph[Mup2ndDiff]{\setlength{\rightskip}{0pt plus 5cm}{\bf RootFindingDoubleT} Mup2ndDiff (muParserHandle\_\-t {\em mupObj}, \/  {\bf RootFindingDoubleT} $\ast$ {\em varPtr})}\hfill}
\label{RootFindingCommon_8c_977a6bd4f033997ff5d5408c9ecf3ec9}


Aproximacao da segunda diferencial no ponto utilizando \char`\"{}Finite difference\char`\"{}. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em mupObj}]Objeto muParser (ponteiro) \item[{\em varPtr}]Ponteiro para a variavel relacionada a expressao no objeto muParser referente a qual variavel deve ser diferenciado \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Valor da segunda diferencial no ponto \end{Desc}


Definition at line 61 of file RootFindingCommon.c.

Referenced by RootFindingBase2nDiffEval().\hypertarget{RootFindingCommon_8c_3d3296b37f9383ae7b5257b5523e0d43}{
\index{RootFindingCommon.c@{RootFindingCommon.c}!MupDiff@{MupDiff}}
\index{MupDiff@{MupDiff}!RootFindingCommon.c@{RootFindingCommon.c}}
\paragraph[MupDiff]{\setlength{\rightskip}{0pt plus 5cm}{\bf RootFindingDoubleT} MupDiff (muParserHandle\_\-t {\em mupObj}, \/  {\bf RootFindingDoubleT} $\ast$ {\em varPtr})}\hfill}
\label{RootFindingCommon_8c_3d3296b37f9383ae7b5257b5523e0d43}


Aproximacao da diferencial no ponto utilizando \char`\"{}regard to a variable\char`\"{} O codigo foi adaptado para C c/ base no metodo Diff da classe muParser (C++), infelizmente a API para C do muParser nao disbonibiliza o metodo Diff. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em mupObj}]Objeto muParser (ponteiro) \item[{\em varPtr}]Ponteiro para a variavel relacionada a expressao no objeto muParser referente a qual variavel deve ser diferenciado \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]Valor da diferencial no ponto \end{Desc}


Definition at line 77 of file RootFindingCommon.c.

Referenced by RootFindingBaseDiffEval().